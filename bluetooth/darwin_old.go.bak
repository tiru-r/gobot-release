//go:build darwin

// Package bluetooth provides Darwin/macOS implementation using Core Bluetooth framework
package bluetooth

/*
#cgo CFLAGS: -x objective-c
#cgo LDFLAGS: -framework Foundation -framework CoreBluetooth
#import <Foundation/Foundation.h>
#import <CoreBluetooth/CoreBluetooth.h>

// ============================================================================
// OBJECTIVE-C INTERFACE DECLARATIONS
// ============================================================================

// Forward declarations
@class CBTManager;
@class CBTCentralManager;
@class CBTPeripheralManager;
@class CBTDevice;
@class CBTService;
@class CBTCharacteristic;

// Main manager interface
@interface CBTManager : NSObject
@property (nonatomic, strong) CBCentralManager *centralManager;
@property (nonatomic, strong) CBPeripheralManager *peripheralManager;
@property (nonatomic, assign) void *goManager;
- (instancetype)initWithGoManager:(void *)manager;
@end

// Central Manager Delegate
@interface CBTCentralManagerDelegate : NSObject <CBCentralManagerDelegate>
@property (nonatomic, assign) void *goCentral;
- (instancetype)initWithGoCentral:(void *)central;
@end

// Peripheral Manager Delegate
@interface CBTPeripheralManagerDelegate : NSObject <CBPeripheralManagerDelegate>
@property (nonatomic, assign) void *goPeripheral;
- (instancetype)initWithGoPeripheral:(void *)peripheral;
@end

// Device (CBPeripheral) Delegate
@interface CBTDeviceDelegate : NSObject <CBPeripheralDelegate>
@property (nonatomic, assign) void *goDevice;
- (instancetype)initWithGoDevice:(void *)device;
@end

// ============================================================================
// C FUNCTION DECLARATIONS
// ============================================================================

// Manager functions
void *CBTManager_New(void *goManager);
void CBTManager_Free(void *manager);
int CBTManager_GetDefaultAdapter(void *manager, void **adapter);

// Central functions
void *CBTCentral_New(void *adapter);
void CBTCentral_Free(void *central);
int CBTCentral_Enable(void *central);
int CBTCentral_Disable(void *central);
int CBTCentral_StartScan(void *central, int timeout);
int CBTCentral_StopScan(void *central);
int CBTCentral_Connect(void *central, const char *identifier, void **device);

// Peripheral functions
void *CBTPeripheral_New(void *adapter);
void CBTPeripheral_Free(void *peripheral);
int CBTPeripheral_Enable(void *peripheral);
int CBTPeripheral_Disable(void *peripheral);
int CBTPeripheral_StartAdvertising(void *peripheral, const char *name, const char *serviceUUID);
int CBTPeripheral_StopAdvertising(void *peripheral);

// Device functions
void *CBTDevice_New(void *central, void *cbPeripheral);
void CBTDevice_Free(void *device);
int CBTDevice_Disconnect(void *device);
int CBTDevice_DiscoverServices(void *device);
const char *CBTDevice_GetName(void *device);
const char *CBTDevice_GetIdentifier(void *device);
int CBTDevice_IsConnected(void *device);

// Callback function types
typedef void (*ScanResultCallback)(void *userData, const char *identifier, const char *name, int rssi);
typedef void (*ConnectionCallback)(void *userData, void *device);
typedef void (*DisconnectionCallback)(void *userData, void *device);
typedef void (*ServiceDiscoveryCallback)(void *userData, void *service);
typedef void (*CharacteristicCallback)(void *userData, void *characteristic, const char *data, int length);

// Callback setters
void CBTCentral_SetScanCallback(void *central, ScanResultCallback callback, void *userData);
void CBTCentral_SetConnectionCallback(void *central, ConnectionCallback callback, void *userData);
void CBTDevice_SetServiceDiscoveryCallback(void *device, ServiceDiscoveryCallback callback, void *userData);

// ============================================================================
// OBJECTIVE-C IMPLEMENTATION
// ============================================================================

@implementation CBTManager

- (instancetype)initWithGoManager:(void *)manager {
    self = [super init];
    if (self) {
        _goManager = manager;
        _centralManager = [[CBCentralManager alloc] initWithDelegate:nil queue:nil];
        _peripheralManager = [[CBPeripheralManager alloc] initWithDelegate:nil queue:nil];
    }
    return self;
}

@end

@implementation CBTCentralManagerDelegate

- (instancetype)initWithGoCentral:(void *)central {
    self = [super init];
    if (self) {
        _goCentral = central;
    }
    return self;
}

- (void)centralManagerDidUpdateState:(CBCentralManager *)central {
    // Handle state updates
}

- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary<NSString *,id> *)advertisementData RSSI:(NSNumber *)RSSI {
    if (self.goCentral) {
        const char *identifier = [peripheral.identifier.UUIDString UTF8String];
        const char *name = [peripheral.name UTF8String];
        scanResultCallbackBridge(self.goCentral, (char *)identifier, (char *)name, [RSSI intValue]);
    }
}

- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral {
    // Handle connection
}

- (void)centralManager:(CBCentralManager *)central didFailToConnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error {
    // Handle connection failure
}

- (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error {
    // Handle disconnection
}

@end

@implementation CBTPeripheralManagerDelegate

- (instancetype)initWithGoPeripheral:(void *)peripheral {
    self = [super init];
    if (self) {
        _goPeripheral = peripheral;
    }
    return self;
}

- (void)peripheralManagerDidUpdateState:(CBPeripheralManager *)peripheral {
    // Handle state updates
}

- (void)peripheralManagerDidStartAdvertising:(CBPeripheralManager *)peripheral error:(NSError *)error {
    // Handle advertising start
}

- (void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveReadRequest:(CBATTRequest *)request {
    // Handle read requests
}

- (void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveWriteRequests:(NSArray<CBATTRequest *> *)requests {
    // Handle write requests
}

- (void)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)central didSubscribeToCharacteristic:(CBCharacteristic *)characteristic {
    // Handle subscription
}

- (void)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)central didUnsubscribeFromCharacteristic:(CBCharacteristic *)characteristic {
    // Handle unsubscription
}

@end

@implementation CBTDeviceDelegate

- (instancetype)initWithGoDevice:(void *)device {
    self = [super init];
    if (self) {
        _goDevice = device;
    }
    return self;
}

- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error {
    // Handle service discovery
}

- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error {
    // Handle characteristic discovery
}

- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error {
    // Handle characteristic value updates
}

- (void)peripheral:(CBPeripheral *)peripheral didWriteValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error {
    // Handle write completion
}

- (void)peripheral:(CBPeripheral *)peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error {
    // Handle notification state changes
}

@end

// ============================================================================
// C FUNCTION IMPLEMENTATIONS
// ============================================================================

void *CBTManager_New(void *goManager) {
    CBTManager *manager = [[CBTManager alloc] initWithGoManager:goManager];
    return (__bridge_retained void *)manager;
}

void CBTManager_Free(void *manager) {
    CBTManager *cbtManager = (__bridge_transfer CBTManager *)manager;
    cbtManager = nil;
}

int CBTManager_GetDefaultAdapter(void *manager, void **adapter) {
    CBTManager *cbtManager = (__bridge CBTManager *)manager;
    *adapter = (__bridge void *)cbtManager;
    return 0;
}

void *CBTCentral_New(void *adapter) {
    CBTManager *manager = (__bridge CBTManager *)adapter;
    CBTCentralManagerDelegate *delegate = [[CBTCentralManagerDelegate alloc] initWithGoCentral:NULL];
    manager.centralManager.delegate = delegate;
    return (__bridge_retained void *)manager.centralManager;
}

void CBTCentral_Free(void *central) {
    CBCentralManager *centralManager = (__bridge_transfer CBCentralManager *)central;
    centralManager = nil;
}

int CBTCentral_Enable(void *central) {
    CBCentralManager *centralManager = (__bridge CBCentralManager *)central;
    return 0;
}

int CBTCentral_Disable(void *central) {
    CBCentralManager *centralManager = (__bridge CBCentralManager *)central;
    return 0;
}

int CBTCentral_StartScan(void *central, int timeout) {
    CBCentralManager *centralManager = (__bridge CBCentralManager *)central;
    if (centralManager.state == CBManagerStatePoweredOn) {
        [centralManager scanForPeripheralsWithServices:nil options:nil];
        return 0;
    }
    return -1;
}

int CBTCentral_StopScan(void *central) {
    CBCentralManager *centralManager = (__bridge CBCentralManager *)central;
    [centralManager stopScan];
    return 0;
}

int CBTCentral_Connect(void *central, const char *identifier, void **device) {
    CBCentralManager *centralManager = (__bridge CBCentralManager *)central;
    NSString *uuidString = [NSString stringWithUTF8String:identifier];
    NSUUID *uuid = [[NSUUID alloc] initWithUUIDString:uuidString];
    
    NSArray *peripherals = [centralManager retrievePeripheralsWithIdentifiers:@[uuid]];
    if (peripherals.count > 0) {
        CBPeripheral *peripheral = peripherals[0];
        [centralManager connectPeripheral:peripheral options:nil];
        *device = (__bridge_retained void *)peripheral;
        return 0;
    }
    return -1;
}

void *CBTPeripheral_New(void *adapter) {
    CBTManager *manager = (__bridge CBTManager *)adapter;
    CBTPeripheralManagerDelegate *delegate = [[CBTPeripheralManagerDelegate alloc] initWithGoPeripheral:NULL];
    manager.peripheralManager.delegate = delegate;
    return (__bridge_retained void *)manager.peripheralManager;
}

void CBTPeripheral_Free(void *peripheral) {
    CBPeripheralManager *peripheralManager = (__bridge_transfer CBPeripheralManager *)peripheral;
    peripheralManager = nil;
}

int CBTPeripheral_Enable(void *peripheral) {
    CBPeripheralManager *peripheralManager = (__bridge CBPeripheralManager *)peripheral;
    return 0;
}

int CBTPeripheral_Disable(void *peripheral) {
    CBPeripheralManager *peripheralManager = (__bridge CBPeripheralManager *)peripheral;
    return 0;
}

int CBTPeripheral_StartAdvertising(void *peripheral, const char *name, const char *serviceUUID) {
    CBPeripheralManager *peripheralManager = (__bridge CBPeripheralManager *)peripheral;
    
    NSMutableDictionary *advertisementData = [NSMutableDictionary dictionary];
    
    if (name) {
        advertisementData[CBAdvertisementDataLocalNameKey] = [NSString stringWithUTF8String:name];
    }
    
    if (serviceUUID) {
        NSString *uuidString = [NSString stringWithUTF8String:serviceUUID];
        CBUUID *uuid = [CBUUID UUIDWithString:uuidString];
        advertisementData[CBAdvertisementDataServiceUUIDsKey] = @[uuid];
    }
    
    if (peripheralManager.state == CBManagerStatePoweredOn) {
        [peripheralManager startAdvertising:advertisementData];
        return 0;
    }
    return -1;
}

int CBTPeripheral_StopAdvertising(void *peripheral) {
    CBPeripheralManager *peripheralManager = (__bridge CBPeripheralManager *)peripheral;
    [peripheralManager stopAdvertising];
    return 0;
}

void *CBTDevice_New(void *central, void *cbPeripheral) {
    CBPeripheral *peripheral = (__bridge CBPeripheral *)cbPeripheral;
    CBTDeviceDelegate *delegate = [[CBTDeviceDelegate alloc] initWithGoDevice:NULL];
    peripheral.delegate = delegate;
    return (__bridge_retained void *)peripheral;
}

void CBTDevice_Free(void *device) {
    CBPeripheral *peripheral = (__bridge_transfer CBPeripheral *)device;
    peripheral = nil;
}

int CBTDevice_Disconnect(void *device) {
    CBPeripheral *peripheral = (__bridge CBPeripheral *)device;
    return 0;
}

int CBTDevice_DiscoverServices(void *device) {
    CBPeripheral *peripheral = (__bridge CBPeripheral *)device;
    [peripheral discoverServices:nil];
    return 0;
}

const char *CBTDevice_GetName(void *device) {
    CBPeripheral *peripheral = (__bridge CBPeripheral *)device;
    return [peripheral.name UTF8String];
}

const char *CBTDevice_GetIdentifier(void *device) {
    CBPeripheral *peripheral = (__bridge CBPeripheral *)device;
    return [peripheral.identifier.UUIDString UTF8String];
}

int CBTDevice_IsConnected(void *device) {
    CBPeripheral *peripheral = (__bridge CBPeripheral *)device;
    return peripheral.state == CBPeripheralStateConnected ? 1 : 0;
}

void CBTCentral_SetScanCallback(void *central, ScanResultCallback callback, void *userData) {
    CBCentralManager *centralManager = (__bridge CBCentralManager *)central;
    CBTCentralManagerDelegate *delegate = (CBTCentralManagerDelegate *)centralManager.delegate;
    delegate.goCentral = userData;
}

void CBTCentral_SetConnectionCallback(void *central, ConnectionCallback callback, void *userData) {
    // Implementation for connection callback
}

void CBTDevice_SetServiceDiscoveryCallback(void *device, ServiceDiscoveryCallback callback, void *userData) {
    CBPeripheral *peripheral = (__bridge CBPeripheral *)device;
    CBTDeviceDelegate *delegate = (CBTDeviceDelegate *)peripheral.delegate;
    delegate.goDevice = userData;
}

*/
import "C"

import (
	"context"
	"fmt"
	"runtime"
	"sync"
	"time"
	"unsafe"
)

// ============================================================================
// TYPE DEFINITIONS
// ============================================================================

// darwinManager implements Manager interface for macOS
type darwinManager struct {
	cManager unsafe.Pointer
	adapters []*darwinAdapter
	mu       sync.RWMutex
}

// darwinAdapter implements Adapter interface for macOS
type darwinAdapter struct {
	manager    *darwinManager
	central    *darwinCentral
	peripheral *darwinPeripheral
	mu         sync.RWMutex
}

// darwinCentral implements Central interface for macOS
type darwinCentral struct {
	adapter      *darwinAdapter
	cCentral     unsafe.Pointer
	scanning     bool
	devices      map[string]*darwinDevice
	scanCallback func(Advertisement)
	mu           sync.RWMutex
}

// darwinPeripheral implements Peripheral interface for macOS
type darwinPeripheral struct {
	adapter     *darwinAdapter
	cPeripheral unsafe.Pointer
	advertising bool
	services    map[string]*darwinPeripheralService
	mu          sync.RWMutex
}

// darwinDevice implements Device interface for macOS
type darwinDevice struct {
	central    *darwinCentral
	cDevice    unsafe.Pointer
	identifier string
	name       string
	connected  bool
	services   map[string]*darwinService
	mu         sync.RWMutex
}

// darwinService implements Service interface for macOS
type darwinService struct {
	device          *darwinDevice
	cService        unsafe.Pointer
	uuid            UUID
	primary         bool
	characteristics map[string]*darwinCharacteristic
	mu              sync.RWMutex
}

// darwinCharacteristic implements Characteristic interface for macOS
type darwinCharacteristic struct {
	service         *darwinService
	cCharacteristic unsafe.Pointer
	uuid            UUID
	properties      CharacteristicProperty
	descriptors     map[string]*darwinDescriptor
	subscribed      bool
	mu              sync.RWMutex
}

// darwinDescriptor implements Descriptor interface for macOS
type darwinDescriptor struct {
	characteristic *darwinCharacteristic
	cDescriptor    unsafe.Pointer
	uuid           UUID
	mu             sync.RWMutex
}

// darwinPeripheralService implements PeripheralService interface for macOS
type darwinPeripheralService struct {
	peripheral      *darwinPeripheral
	cService        unsafe.Pointer
	uuid            UUID
	primary         bool
	characteristics map[string]*darwinPeripheralCharacteristic
	mu              sync.RWMutex
}

// darwinPeripheralCharacteristic implements PeripheralCharacteristic interface for macOS
type darwinPeripheralCharacteristic struct {
	service       *darwinPeripheralService
	cCharacteristic unsafe.Pointer
	uuid          UUID
	properties    CharacteristicProperty
	value         []byte
	onRead        func() []byte
	onWrite       func([]byte) error
	onSubscribe   func()
	onUnsubscribe func()
	mu            sync.RWMutex
}

// ============================================================================
// GLOBAL VARIABLES
// ============================================================================

var (
	// Global callback maps to handle C callbacks
	scanCallbacks       = make(map[unsafe.Pointer]func(Advertisement))
	connectionCallbacks = make(map[unsafe.Pointer]func(Device))
	callbackMutex       sync.RWMutex
)

// ============================================================================
// PLATFORM MANAGER IMPLEMENTATION
// ============================================================================

// getPlatformManager returns the macOS implementation of Manager
func getPlatformManager() (Manager, error) {
	manager := &darwinManager{}
	
	cManager := C.CBTManager_New(unsafe.Pointer(manager))
	if cManager == nil {
		return nil, fmt.Errorf("failed to create Core Bluetooth manager")
	}
	
	manager.cManager = cManager
	runtime.SetFinalizer(manager, (*darwinManager).finalize)
	
	// Create default adapter
	var cAdapter unsafe.Pointer
	result := C.CBTManager_GetDefaultAdapter(cManager, &cAdapter)
	if result != 0 {
		return nil, fmt.Errorf("failed to get default adapter")
	}
	
	adapter := &darwinAdapter{manager: manager}
	adapter.central = &darwinCentral{
		adapter: adapter,
		devices: make(map[string]*darwinDevice),
	}
	adapter.peripheral = &darwinPeripheral{
		adapter:  adapter,
		services: make(map[string]*darwinPeripheralService),
	}
	
	// Create Core Bluetooth central and peripheral managers
	adapter.central.cCentral = C.CBTCentral_New(cAdapter)
	adapter.peripheral.cPeripheral = C.CBTPeripheral_New(cAdapter)
	
	manager.adapters = []*darwinAdapter{adapter}
	
	return manager, nil
}

// ============================================================================
// MANAGER INTERFACE IMPLEMENTATION
// ============================================================================

func (m *darwinManager) finalize() {
	if m.cManager != nil {
		C.CBTManager_Free(m.cManager)
		m.cManager = nil
	}
}

func (m *darwinManager) DefaultAdapter() (Adapter, error) {
	m.mu.RLock()
	defer m.mu.RUnlock()
	
	if len(m.adapters) == 0 {
		return nil, fmt.Errorf("no adapters available")
	}
	
	return m.adapters[0], nil
}

func (m *darwinManager) Adapters() ([]Adapter, error) {
	m.mu.RLock()
	defer m.mu.RUnlock()
	
	adapters := make([]Adapter, len(m.adapters))
	for i, adapter := range m.adapters {
		adapters[i] = adapter
	}
	
	return adapters, nil
}

func (m *darwinManager) OnAdapterAdded(callback func(Adapter)) {
	// macOS typically has one adapter, so this is mostly a no-op
}

func (m *darwinManager) OnAdapterRemoved(callback func(Adapter)) {
	// macOS typically has one adapter, so this is mostly a no-op
}

// ============================================================================
// ADAPTER INTERFACE IMPLEMENTATION
// ============================================================================

func (a *darwinAdapter) Central() Central {
	return a.central
}

func (a *darwinAdapter) Peripheral() Peripheral {
	return a.peripheral
}

func (a *darwinAdapter) Address() Address {
	// Core Bluetooth doesn't expose the adapter's MAC address for privacy reasons
	return Address{}
}

func (a *darwinAdapter) Name() string {
	return "macOS Bluetooth Adapter"
}

func (a *darwinAdapter) SetName(name string) error {
	// Core Bluetooth doesn't allow setting adapter name
	return ErrNotSupported
}

func (a *darwinAdapter) PowerState() bool {
	// Would need to check CBManagerState
	return true
}

func (a *darwinAdapter) SetPowerState(enabled bool) error {
	// Core Bluetooth doesn't allow controlling power state programmatically
	return ErrNotSupported
}

// ============================================================================
// CENTRAL INTERFACE IMPLEMENTATION
// ============================================================================

func (c *darwinCentral) Enable(ctx context.Context) error {
	result := C.CBTCentral_Enable(c.cCentral)
	if result != 0 {
		return fmt.Errorf("failed to enable central manager")
	}
	return nil
}

func (c *darwinCentral) Disable(ctx context.Context) error {
	result := C.CBTCentral_Disable(c.cCentral)
	if result != 0 {
		return fmt.Errorf("failed to disable central manager")
	}
	return nil
}

func (c *darwinCentral) Scan(ctx context.Context, params ScanParams, callback func(Advertisement)) error {
	c.mu.Lock()
	if c.scanning {
		c.mu.Unlock()
		return fmt.Errorf("scan already in progress")
	}
	c.scanning = true
	c.scanCallback = callback
	c.mu.Unlock()
	
	defer func() {
		c.mu.Lock()
		c.scanning = false
		c.scanCallback = nil
		c.mu.Unlock()
	}()
	
	// Register callback
	callbackMutex.Lock()
	scanCallbacks[c.cCentral] = callback
	callbackMutex.Unlock()
	
	C.CBTCentral_SetScanCallback(c.cCentral, (C.ScanResultCallback)(C.scanResultCallbackBridge), unsafe.Pointer(c))
	
	timeout := int(params.Timeout.Seconds())
	result := C.CBTCentral_StartScan(c.cCentral, C.int(timeout))
	if result != 0 {
		return fmt.Errorf("failed to start scan")
	}
	
	// Wait for timeout or context cancellation
	timer := time.NewTimer(params.Timeout)
	defer timer.Stop()
	
	select {
	case <-ctx.Done():
		return ctx.Err()
	case <-timer.C:
		return c.StopScan(ctx)
	}
}

func (c *darwinCentral) StopScan(ctx context.Context) error {
	result := C.CBTCentral_StopScan(c.cCentral)
	if result != 0 {
		return fmt.Errorf("failed to stop scan")
	}
	
	c.mu.Lock()
	c.scanning = false
	c.mu.Unlock()
	
	return nil
}

func (c *darwinCentral) Connect(ctx context.Context, address Address, params ConnectionParams) (Device, error) {
	identifier := address.String()
	
	var cDevice unsafe.Pointer
	cIdentifier := C.CString(identifier)
	defer C.free(unsafe.Pointer(cIdentifier))
	
	result := C.CBTCentral_Connect(c.cCentral, cIdentifier, &cDevice)
	if result != 0 {
		return nil, fmt.Errorf("failed to connect to device")
	}
	
	device := &darwinDevice{
		central:    c,
		cDevice:    cDevice,
		identifier: identifier,
		connected:  true,
		services:   make(map[string]*darwinService),
	}
	
	c.mu.Lock()
	c.devices[identifier] = device
	c.mu.Unlock()
	
	return device, nil
}

func (c *darwinCentral) ConnectedDevices() []Device {
	c.mu.RLock()
	defer c.mu.RUnlock()
	
	devices := make([]Device, 0, len(c.devices))
	for _, device := range c.devices {
		if device.connected {
			devices = append(devices, device)
		}
	}
	
	return devices
}

// ============================================================================
// DEVICE INTERFACE IMPLEMENTATION
// ============================================================================

func (d *darwinDevice) Disconnect(ctx context.Context) error {
	d.mu.Lock()
	defer d.mu.Unlock()
	
	if !d.connected {
		return fmt.Errorf("device not connected")
	}
	
	result := C.CBTDevice_Disconnect(d.cDevice)
	if result != 0 {
		return fmt.Errorf("failed to disconnect device")
	}
	
	d.connected = false
	return nil
}

func (d *darwinDevice) DiscoverServices(ctx context.Context, serviceUUIDs []UUID) ([]Service, error) {
	d.mu.Lock()
	defer d.mu.Unlock()
	
	if !d.connected {
		return nil, fmt.Errorf("device not connected")
	}
	
	result := C.CBTDevice_DiscoverServices(d.cDevice)
	if result != 0 {
		return nil, fmt.Errorf("failed to discover services")
	}
	
	// Wait for service discovery to complete
	// In a real implementation, this would use callbacks
	time.Sleep(100 * time.Millisecond)
	
	services := make([]Service, 0, len(d.services))
	for _, service := range d.services {
		services = append(services, service)
	}
	
	return services, nil
}

func (d *darwinDevice) Address() Address {
	return parseAddress(d.identifier)
}

func (d *darwinDevice) Name() string {
	if d.name == "" {
		cName := C.CBTDevice_GetName(d.cDevice)
		if cName != nil {
			d.name = C.GoString(cName)
		}
	}
	return d.name
}

func (d *darwinDevice) Connected() bool {
	d.mu.RLock()
	defer d.mu.RUnlock()
	return d.connected
}

func (d *darwinDevice) RSSI() int16 {
	// Would need to implement RSSI reading in Core Bluetooth
	return 0
}

func (d *darwinDevice) Services() []Service {
	d.mu.RLock()
	defer d.mu.RUnlock()
	
	services := make([]Service, 0, len(d.services))
	for _, service := range d.services {
		services = append(services, service)
	}
	return services
}

// ============================================================================
// SERVICE INTERFACE IMPLEMENTATION
// ============================================================================

func (s *darwinService) UUID() UUID {
	return s.uuid
}

func (s *darwinService) Primary() bool {
	return s.primary
}

func (s *darwinService) Device() Device {
	return s.device
}

func (s *darwinService) DiscoverCharacteristics(ctx context.Context, characteristicUUIDs []UUID) ([]Characteristic, error) {
	s.mu.Lock()
	defer s.mu.Unlock()
	
	// In a real implementation, this would call Core Bluetooth APIs
	// For now, return existing characteristics
	characteristics := make([]Characteristic, 0, len(s.characteristics))
	for _, characteristic := range s.characteristics {
		characteristics = append(characteristics, characteristic)
	}
	
	return characteristics, nil
}

func (s *darwinService) Characteristics() []Characteristic {
	s.mu.RLock()
	defer s.mu.RUnlock()
	
	characteristics := make([]Characteristic, 0, len(s.characteristics))
	for _, characteristic := range s.characteristics {
		characteristics = append(characteristics, characteristic)
	}
	return characteristics
}

// ============================================================================
// CHARACTERISTIC INTERFACE IMPLEMENTATION
// ============================================================================

func (c *darwinCharacteristic) UUID() UUID {
	return c.uuid
}

func (c *darwinCharacteristic) Service() Service {
	return c.service
}

func (c *darwinCharacteristic) Properties() CharacteristicProperty {
	return c.properties
}

func (c *darwinCharacteristic) Read(ctx context.Context) ([]byte, error) {
	c.mu.Lock()
	defer c.mu.Unlock()
	
	if (c.properties & PropertyRead) == 0 {
		return nil, fmt.Errorf("characteristic does not support reading")
	}
	
	// In a real implementation, this would call Core Bluetooth APIs
	// For now, return empty data
	return []byte{}, nil
}

func (c *darwinCharacteristic) Write(ctx context.Context, data []byte, withResponse bool) error {
	c.mu.Lock()
	defer c.mu.Unlock()
	
	if withResponse && (c.properties&PropertyWrite) == 0 {
		return fmt.Errorf("characteristic does not support write with response")
	}
	if !withResponse && (c.properties&PropertyWriteWithoutResponse) == 0 {
		return fmt.Errorf("characteristic does not support write without response")
	}
	
	// In a real implementation, this would call Core Bluetooth APIs
	return nil
}

func (c *darwinCharacteristic) StartNotifications(ctx context.Context, callback func([]byte)) error {
	c.mu.Lock()
	defer c.mu.Unlock()
	
	if (c.properties & PropertyNotify) == 0 {
		return fmt.Errorf("characteristic does not support notifications")
	}
	
	if c.subscribed {
		return fmt.Errorf("already subscribed to notifications")
	}
	
	// In a real implementation, this would call Core Bluetooth APIs
	c.subscribed = true
	return nil
}

func (c *darwinCharacteristic) StopNotifications(ctx context.Context) error {
	c.mu.Lock()
	defer c.mu.Unlock()
	
	if !c.subscribed {
		return fmt.Errorf("not subscribed to notifications")
	}
	
	// In a real implementation, this would call Core Bluetooth APIs
	c.subscribed = false
	return nil
}

func (c *darwinCharacteristic) DiscoverDescriptors(ctx context.Context) ([]Descriptor, error) {
	c.mu.Lock()
	defer c.mu.Unlock()
	
	descriptors := make([]Descriptor, 0, len(c.descriptors))
	for _, descriptor := range c.descriptors {
		descriptors = append(descriptors, descriptor)
	}
	
	return descriptors, nil
}

func (c *darwinCharacteristic) Descriptors() []Descriptor {
	c.mu.RLock()
	defer c.mu.RUnlock()
	
	descriptors := make([]Descriptor, 0, len(c.descriptors))
	for _, descriptor := range c.descriptors {
		descriptors = append(descriptors, descriptor)
	}
	return descriptors
}

// ============================================================================
// PERIPHERAL INTERFACE IMPLEMENTATION
// ============================================================================

func (p *darwinPeripheral) Enable(ctx context.Context) error {
	result := C.CBTPeripheral_Enable(p.cPeripheral)
	if result != 0 {
		return fmt.Errorf("failed to enable peripheral manager")
	}
	return nil
}

func (p *darwinPeripheral) Disable(ctx context.Context) error {
	result := C.CBTPeripheral_Disable(p.cPeripheral)
	if result != 0 {
		return fmt.Errorf("failed to disable peripheral manager")
	}
	return nil
}

func (p *darwinPeripheral) StartAdvertising(ctx context.Context, params AdvertisingParams) error {
	p.mu.Lock()
	defer p.mu.Unlock()
	
	if p.advertising {
		return fmt.Errorf("already advertising")
	}
	
	cName := C.CString(params.LocalName)
	defer C.free(unsafe.Pointer(cName))
	
	var cServiceUUID *C.char
	if len(params.ServiceUUIDs) > 0 {
		cServiceUUID = C.CString(params.ServiceUUIDs[0].String())
		defer C.free(unsafe.Pointer(cServiceUUID))
	}
	
	result := C.CBTPeripheral_StartAdvertising(p.cPeripheral, cName, cServiceUUID)
	if result != 0 {
		return fmt.Errorf("failed to start advertising")
	}
	
	p.advertising = true
	return nil
}

func (p *darwinPeripheral) StopAdvertising(ctx context.Context) error {
	p.mu.Lock()
	defer p.mu.Unlock()
	
	if !p.advertising {
		return fmt.Errorf("not advertising")
	}
	
	result := C.CBTPeripheral_StopAdvertising(p.cPeripheral)
	if result != 0 {
		return fmt.Errorf("failed to stop advertising")
	}
	
	p.advertising = false
	return nil
}

func (p *darwinPeripheral) AddService(ctx context.Context, service PeripheralService) error {
	p.mu.Lock()
	defer p.mu.Unlock()
	
	darwinService, ok := service.(*darwinPeripheralService)
	if !ok {
		return fmt.Errorf("invalid service type")
	}
	
	p.services[darwinService.uuid.String()] = darwinService
	return nil
}

func (p *darwinPeripheral) RemoveService(ctx context.Context, service PeripheralService) error {
	p.mu.Lock()
	defer p.mu.Unlock()
	
	darwinService, ok := service.(*darwinPeripheralService)
	if !ok {
		return fmt.Errorf("invalid service type")
	}
	
	delete(p.services, darwinService.uuid.String())
	return nil
}

func (p *darwinPeripheral) Services() []PeripheralService {
	p.mu.RLock()
	defer p.mu.RUnlock()
	
	services := make([]PeripheralService, 0, len(p.services))
	for _, service := range p.services {
		services = append(services, service)
	}
	return services
}

// ============================================================================
// PERIPHERAL SERVICE INTERFACE IMPLEMENTATION
// ============================================================================

func (s *darwinPeripheralService) UUID() UUID {
	return s.uuid
}

func (s *darwinPeripheralService) Primary() bool {
	return s.primary
}

func (s *darwinPeripheralService) AddCharacteristic(ctx context.Context, characteristic PeripheralCharacteristic) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	
	darwinCharacteristic, ok := characteristic.(*darwinPeripheralCharacteristic)
	if !ok {
		return fmt.Errorf("invalid characteristic type")
	}
	
	s.characteristics[darwinCharacteristic.uuid.String()] = darwinCharacteristic
	return nil
}

func (s *darwinPeripheralService) RemoveCharacteristic(ctx context.Context, characteristic PeripheralCharacteristic) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	
	darwinCharacteristic, ok := characteristic.(*darwinPeripheralCharacteristic)
	if !ok {
		return fmt.Errorf("invalid characteristic type")
	}
	
	delete(s.characteristics, darwinCharacteristic.uuid.String())
	return nil
}

func (s *darwinPeripheralService) Characteristics() []PeripheralCharacteristic {
	s.mu.RLock()
	defer s.mu.RUnlock()
	
	characteristics := make([]PeripheralCharacteristic, 0, len(s.characteristics))
	for _, characteristic := range s.characteristics {
		characteristics = append(characteristics, characteristic)
	}
	return characteristics
}

// ============================================================================
// PERIPHERAL CHARACTERISTIC INTERFACE IMPLEMENTATION
// ============================================================================

func (c *darwinPeripheralCharacteristic) UUID() UUID {
	return c.uuid
}

func (c *darwinPeripheralCharacteristic) Properties() CharacteristicProperty {
	return c.properties
}

func (c *darwinPeripheralCharacteristic) Value() []byte {
	c.mu.RLock()
	defer c.mu.RUnlock()
	return c.value
}

func (c *darwinPeripheralCharacteristic) SetValue(value []byte) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.value = value
}

func (c *darwinPeripheralCharacteristic) SetReadHandler(handler func() []byte) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.onRead = handler
}

func (c *darwinPeripheralCharacteristic) SetWriteHandler(handler func([]byte) error) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.onWrite = handler
}

func (c *darwinPeripheralCharacteristic) SetSubscriptionHandler(onSubscribe func(), onUnsubscribe func()) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.onSubscribe = onSubscribe
	c.onUnsubscribe = onUnsubscribe
}

func (c *darwinPeripheralCharacteristic) Notify(ctx context.Context, data []byte) error {
	c.mu.Lock()
	defer c.mu.Unlock()
	
	if (c.properties & PropertyNotify) == 0 {
		return fmt.Errorf("characteristic does not support notifications")
	}
	
	// In a real implementation, this would send notification through Core Bluetooth
	return nil
}

// ============================================================================
// C CALLBACK BRIDGE FUNCTIONS
// ============================================================================

//export scanResultCallbackBridge
func scanResultCallbackBridge(userData unsafe.Pointer, identifier *C.char, name *C.char, rssi C.int) {
	central := (*darwinCentral)(userData)
	
	callbackMutex.RLock()
	callback, exists := scanCallbacks[central.cCentral]
	callbackMutex.RUnlock()
	
	if exists && callback != nil {
		advertisement := Advertisement{
			Address:   parseAddress(C.GoString(identifier)),
			RSSI:      int16(rssi),
			LocalName: C.GoString(name),
		}
		callback(advertisement)
	}
}

//export connectionCallbackBridge
func connectionCallbackBridge(userData unsafe.Pointer, cDevice unsafe.Pointer) {
	// Handle connection events
}

//export disconnectionCallbackBridge
func disconnectionCallbackBridge(userData unsafe.Pointer, cDevice unsafe.Pointer) {
	// Handle disconnection events
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

func parseAddress(identifier string) Address {
	// Convert Core Bluetooth identifier to Address
	// This is a simplified implementation
	addr, _ := ParseAddress(identifier)
	return addr
}